<!DOCTYPE html>
<html>
  <head>
    <title>Projet INPS</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="core/fonts/mono.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/animate.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/style_core.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/mermaid.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/gitgraph.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/style_ensiie.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/katex.css"> 
    <link rel="stylesheet" type="text/css" href="core/css/asciinema-player.css">

  </head>
  <body>
    <textarea id="source" readonly>
class: titlepage

.title[
Advanced Scientific Programming - Project
]

.subtitle[
Valentin GACHON / Hugo LALLEMANT / Elouan LESTEVEN - ENSIIE - 2023
]


.footnote[
[Retour au début](./index.html)
]

---
layout: true
class: animated fadeIn middle numbers

.footnote[
Valentin GACHON / Hugo LALLEMANT / Elouan LESTEVEN - [Retour au début](./index.html)
]

---

class: middle
# Plan

1. Field Generator

2. Solver

3. Post-processor

4. Database

5. Physical application

---

# Arborescence

.alert.tree.hcenter[
Projet/
* bin/
* bindings/
* headers/
	* constantes.h
	* solver.h
* obj/
* src_cpp/
	* solver.cpp
* src_py/
	* field_generator.py
	* initial_wave_function.py
  * potential.py
* test/
  * test_solver.h
* Makefile
]

---

  # Field generator

  ## Initial wave function

  ### Hermite

  On utilise la relation de récurrence:
  `$$H_{0}(z)=1 $$` `$$H_{1}(z)=2z$$` `$$H_{n+1}(z)=2zH_{n}(z)-2nH_{n-1}(z)$$`
  
  ```python
  def hermite(n, x):
    h = np.zeros((n+1, len(x)))

    h[0] = np.ones((1, len(x)))
    if n == 0:
        return h

    h[1] = 2*x
    
    for i in range(2, n+1):
        h[i] = 2*x*h[i-1] - 2*(i-1)*h[i-2]
    return h
  
  ```

---
#Field generator
## 2D-HO

`$$\forall n_x\ge 0,\, \forall n_y\ge 0,\, \psi_{n_x,n_y}(x,y)=\psi_{n_x}(x).\psi_{n_y}(y),$$`
with
`$$\forall u \in \{x,y\},\hspace{5mm}\psi_{n_u}(u) = \frac{1}{\sqrt{2^{n_u} n_u!}}\left(\frac{m\omega}{\pi\hbar}\right)^{1/4}e^{-\frac{m\omega u^2}{2\hbar}}H_{n_u}\left(\sqrt{\frac{m\omega}{\hbar}} . u\right).$$`


```python
def solution1D(n, x, h, m=1, w=1, hbar=1):
    x = math.pow(m*w/(hbar*math.pi), 0.25) * np.exp(-m*w*x*x/(2*hbar)).reshape(1, len(x))
    psi = x * h[n] / math.sqrt(math.pow(2, n) * math.factorial(n))
    return psi

def solution2D(nx, ny, x, y, hx, hy, m=1, w=1, hbar=1):
    psix = np.transpose(solution1D(nx, x, hx, m, w, hbar))
    psiy = solution1D(ny, y, hy, m, w, hbar)
    return psix @ psiy

def solutionMix(deg_array_x, deg_array_y, proportion_array, x, y, m=1, w=1, hbar=1):
psi = np.zeros((len(x), len(y)))
hx = hermite(np.max(deg_array_x), x)
hy = hermite(np.max(deg_array_y), y)
for i in range(len(deg_array_x)):
    psi += proportion_array[i] * solution2D(deg_array_x[i], deg_array_y[i], x, y, hx, hy, m, w, hbar)
return psi

```

---
#Field generator
## Gaussian wave packet with initial speed

`$$
\psi_0(x,y) \equiv A.e^{-\left[\frac{(x - x_0)^2+(y - y_0)^2}{w^2}\right]}.e^{i\left[k_x.x+k_y.y\right]}
$$`

```python
def gaussian_packet(x, x0, y, y0, kx, ky, w=1):
    resx = np.transpose(np.exp(-((x-x0)**2)/(w**2)) * np.exp(1j*(kx*x)).reshape(1, len(x)))
    resy = np.exp(-((y-y0)**2)/(w**2)) * np.exp(1j*(ky*y)).reshape(1, len(y))
    res = resx @ resy
    return np.sqrt(2) * res / (w * np.sqrt(np.pi))

```

---

# Field generator

##Potential

```python
def from_img(path, min, max):
    img = np.asarray(Image.open(path).convert('L'), dtype=np.float64)
    v = img*(max-min)/255 + min
    return v

def from_formula(x, y, k, nx, ny):
    x = np.tile(x, (len(y), 1)).T
    y = np.tile(y, (len(x[0]), 1))
    return k*(np.power(x, nx)+np.power(y, ny))   
```
---

# Basis
## Calcul de zPart

`$$
Z(z, n_z)
\equiv
         \frac{1}{\sqrt{b_z}}
         \frac{1}{\sqrt{2^{n_z} \sqrt{\pi}n_z!}}
         e^{-\frac{z^2}{2b_z^2}}H_{n_z}\left(\frac{z}{b_z}\right)
$$`

```cpp
// @brief Calculates the Z functions which are the Z dependent part of psi,
// without using precalculated hermite polynomial values.
// Warning: hermite is calculated at each call of this method.
// @param z z vector
// @param nz quantum number not dependent on z
// @return arma::vec containing the values of the Z part of the solutions.
arma::vec Basis::zPart(arma::vec z, int nz){
	Poly poly;
	poly.calcHermite(nz+1, z/bz);
	arma::vec Hnz = poly.hermite(nz);

	return (1/(pow(bz*pow(2,nz)*pow(M_PI,0.5)*tgamma(nz+1),0.5)))*arma::exp(-arma::pow(z,2)/(2*pow(bz,2)))%Hnz;
}
```
```cpp
// @brief Calculates the Z functions which are the Z dependent part of psi,
// using precalculated hermite polynomial values.
// @param z z vector
// @param nz quantum number not dependent on z
// @param hermite_nz vector containing the values of the hermite polynomial
// @return arma::vec containing the values of the Z part of the solutions.
arma::vec Basis::zPart(arma::vec z, int nz, arma::vec Hnz){
	return (1/(pow(bz*pow(2,nz)*pow(M_PI,0.5)*tgamma(nz+1),0.5)))*arma::exp(-arma::pow(z,2)/(2*pow(bz,2)))%Hnz;
} 
```

---

# Basis
## Calcul de rPart

`$$
R(r_\perp, m, n)
         \equiv
         \frac{1}{b_{\perp}\sqrt{\pi}}
         \sqrt{\frac{n!}{(n+|m|)!}}
         e^{-\frac{r_{\perp}^2}{2b_{\perp}^2}}
         \left(\frac{r_{\perp}}{b_{\perp}}\right)^{|m|}
         L_n^{|m|}\left(\frac{r_{\perp}^2}{b_{\perp}^2}\right).
$$`

```cpp
// Method to calculate the R part of the solutions without using precalculated laguerre polynomial values.
// Warning: laguerre is calculated at each call of this method.
// @param rVec vector containing the values of r.
// @param m quantum number.
// @param n quantum number.
// @return arma::vec containing the values of the R part of the solutions.
arma::vec Basis::rPart(arma::vec rVec, int m, int n){
  Poly poly;
  poly.calcLaguerre(m+1, n+1, arma::pow(rVec, 2)/pow(br, 2));
  
  arma::vec result = sqrt(tgamma(n+1)/tgamma(n+abs(m)+1))*arma::exp(-arma::pow(rVec, 2)/
  (2*pow(br, 2)))%arma::pow(rVec/br, abs(m))%poly.laguerre(m, n)/(br*sqrt(M_PI));
  return result;
}
```
```cpp
// Method to calculate the R part of the solutions using precalculated laguerre polynomial values.
// @param rVec vector containing the values of r.
// @param m quantum number.
// @param n quantum number.
// @param laguerre_m_n vector containing the values of the laguerre polynomial
// @return arma::vec containing the values of the R part of the solutions.
arma::vec Basis::rPart(arma::vec rVec, int m, int n, arma::vec laguerre_m_n){
  arma::vec result = sqrt(tgamma(n+1)/tgamma(n+abs(m)+1))*arma::exp(-arma::pow(rVec, 2)/
  (2*pow(br, 2)))%arma::pow(rVec/br, abs(m))%laguerre_m_n/(br*sqrt(M_PI));
  return result;
} 
```

---

#Basis
## Calcul des $\psi$

`$$
\psi_{m,n,n_z}(r_\perp, \theta, z)
        \equiv
    Z(z, n_z)
    .
    R(r_\perp, m, n)
    .
         e^{im\theta}
$$`

```cpp
// @brief Calculates the psi function
// @param r r vector
// @param z z vector
// @param m quantum number
// @param n quantum number
// @param nz quantum number
// @return arma::mat containing the values of the psi function
arma::mat Basis::psi(arma::vec r, arma::vec z, int m, int n, int nz, arma::vec laguerre_m_n, arma::vec hermite_nz){
	arma::vec rPartVec = rPart(r, m, n, laguerre_m_n);
	arma::vec zPartVec = zPart(z, nz, hermite_nz);
	arma::mat psiMat = rPartVec*(zPartVec.t());
	return psiMat;
}
```

---

#Basis
##Tests

![](images/tests.png)

---

#Calcul / Base
```cpp
  arma::mat rho;
  rho.load("data/rho.arma", arma::arma_ascii);
  //Initializing the indexes matrix to get rho values from m, n and n_z
  arma::cube indexes = arma::zeros<arma::cube>(basis.mMax, basis.nMax.max(), basis.n_zMax.max());
  int k = 0;
  for (int m = 0; m < basis.mMax; m++)
  {
    for (int n = 0; n < basis.nMax(m); n++)
    {
      for (int n_z = 0; n_z < basis.n_zMax(m, n); n_z++)
      {
        indexes(m, n, n_z) = k;
        k++;
      }
    }
  }

  //Initializing the polynomials and precalculating them
  Poly poly;
  poly.calcLaguerre(basis.mMax, basis.nMax.max(), arma::pow(rVals, 2)/pow(basis.br, 2));
  poly.calcHermite(basis.n_zMax.max(), zVals/basis.bz);
```

---

#Calcul / Algorithme naïf
```cpp
//V0 - naive algorithm
arma::mat result0 = arma::zeros(rVals.n_rows, zVals.n_rows); // number of points on r- and z- axes
for (int m = 0; m < basis.mMax; m++)
{
  for (int n = 0; n < basis.nMax(m); n++)
  {
    for (int n_z = 0; n_z < basis.n_zMax(m, n); n_z++)
    {
      i = indexes(m, n, n_z);
      for (int mp = 0; mp < basis.mMax; mp++)
      {
        for (int np = 0; np < basis.nMax(mp); np++)
        {
          for (int n_zp = 0; n_zp < basis.n_zMax(mp, np); n_zp++)
          {
            j = indexes(mp, np, n_zp);
            arma::mat psiA = basis.psi(rVals, zVals, m,  n,  n_z, poly.laguerre(m, n), poly.hermite(n_z));
            arma::mat psiB = basis.psi(rVals, zVals, mp, np, n_zp, poly.laguerre(mp, np), poly.hermite(n_zp));
            result0 += psiA % psiB * rho(i, j);
            
          }
        }
      }
    }
  }
}
```
.alert.hcenter[**3.589s**]

---

#Calcul / Optimisation #1 m-symmétrie de $\eta$
```cpp
//V1 - removing calculations for ma != mb 
arma::mat result1 = arma::zeros(rVals.n_rows, zVals.n_rows); // number of points on r- and z- axes
for (int m = 0; m < basis.mMax; m++)
{
  for (int n = 0; n < basis.nMax(m); n++)
  {
    for (int n_z = 0; n_z < basis.n_zMax(m, n); n_z++)
    {
      i = indexes(m, n, n_z);
      for (int np = 0; np < basis.nMax(m); np++)
      {
        for (int n_zp = 0; n_zp < basis.n_zMax(m, np); n_zp++)
        {
 
          j = indexes(m, np, n_zp);
          arma::mat psiA = basis.psi(rVals, zVals, m,  n,  n_z, poly.laguerre(m, n), poly.hermite(n_z));
          arma::mat psiB = basis.psi(rVals, zVals, m, np, n_zp, poly.laguerre(m, np), poly.hermite(n_zp));
          result1 += psiA % psiB * rho(i, j);
        }
      }
    }
  }
}
```
.alert.hcenter[**0.398s** | Gain: **9.01**]

---

#Calcul / Optimisation #2 Décallage dans les boucles
```cpp
//V2 - moving the calculation of the first psi outside of the second loop
arma::mat result2 = arma::zeros(rVals.n_rows, zVals.n_rows); // number of points on r- and z- axes
for (int m = 0; m < basis.mMax; m++)
{
  for (int n = 0; n < basis.nMax(m); n++)
  {
    for (int n_z = 0; n_z < basis.n_zMax(m, n); n_z++)
    {
      i = indexes(m, n, n_z);
      arma::mat psiA = basis.psi(rVals, zVals, m,  n,  n_z, poly.laguerre(m, n), poly.hermite(n_z));
      for (int np = 0; np < basis.nMax(m); np++)
      {
        for (int n_zp = 0; n_zp < basis.n_zMax(m, np); n_zp++)
        {   
          j = indexes(m, np, n_zp);
          arma::mat psiB = basis.psi(rVals, zVals, m, np, n_zp, poly.laguerre(m, np), poly.hermite(n_zp));
          result2 += psiA % psiB * rho(i, j);
        }
      }
    }
  }
}
```
.alert.hcenter[**0.294s** | Gain: **1.35**]

---

#Calcul / Optimisation #3 Précalcul des $\psi$
```cpp
//V3 - precalculating psi
arma::cube psi_precalculate(rVals.n_rows, zVals.n_rows, basis.mMax*basis.nMax.max()*basis.n_zMax.max());
for (int m = 0; m < basis.mMax; m++)
{
  for (int n = 0; n < basis.nMax(m); n++)
  {
    for (int n_z = 0; n_z < basis.n_zMax(m, n); n_z++)
    {
      psi_precalculate.slice(indexes(m, n, n_z)) = basis.psi(rVals, zVals, m,  n,  n_z, poly.laguerre(m, n), poly.hermite(n_z));
    }
  }
}
arma::mat result3 = arma::zeros(rVals.n_rows, zVals.n_rows); // number of points on r- and z- axes
for (int m = 0; m < basis.mMax; m++)
{
  for (int n = 0; n < basis.nMax(m); n++)
  {
    for (int n_z = 0; n_z < basis.n_zMax(m, n); n_z++)
    {
      i = indexes(m, n, n_z);
      for (int np = 0; np < basis.nMax(m); np++)
      {
        for (int n_zp = 0; n_zp < basis.n_zMax(m, np); n_zp++)
        {   
          j = indexes(m, np, n_zp);
          result3 += psi_precalculate.slice(i) % psi_precalculate.slice(j) * rho(i, j);
        }
      }
    }
  }
}
```
.alert.hcenter[**0.210s** | Gain: **1.39**]

---

#Calcul / Optimisation #4 Factorisation de $\psi\_a$
```cpp
//V4 - Factorizing by psiA
arma::cube psi_precalculate_v4(rVals.n_rows, zVals.n_rows, basis.mMax*basis.nMax.max()*basis.n_zMax.max());
for (int m = 0; m < basis.mMax; m++)
{
  for (int n = 0; n < basis.nMax(m); n++)
  {
    for (int n_z = 0; n_z < basis.n_zMax(m, n); n_z++)
    {
      psi_precalculate_v4.slice(indexes(m, n, n_z)) = basis.psi(rVals, zVals, m,  n,  n_z, poly.laguerre(m, n), poly.hermite(n_z));
    }
  }
}
arma::mat result4 = arma::zeros(rVals.n_rows, zVals.n_rows); // number of points on r- and z- axes
arma::mat result_temp = arma::zeros(rVals.n_rows, zVals.n_rows);
for (int m = 0; m < basis.mMax; m++)
{
  for (int n = 0; n < basis.nMax(m); n++)
  {
    for (int n_z = 0; n_z < basis.n_zMax(m, n); n_z++)
    {
      i = indexes(m, n, n_z);
      for (int np = 0; np < basis.nMax(m); np++)
      {
        for (int n_zp = 0; n_zp < basis.n_zMax(m, np); n_zp++)
        {   
          j = indexes(m, np, n_zp);
          result_temp += psi_precalculate_v4.slice(j) * rho(i, j);
        }
      }
      result4 += psi_precalculate_v4.slice(i)%result_temp;
      result_temp.zeros();
    }
  }
}
```
.alert.hcenter[**0.114s** | Gain: **1.84**]

---

#Calcul / Optimisation #5 Symmétrie de $\rho$

```cpp
//V5 - Using symmetry to reduce the number of calculations
arma::cube psi_precalculate_v5(rVals.n_rows, zVals.n_rows, basis.mMax*basis.nMax.max()*basis.n_zMax.max());
for (int m = 0; m < basis.mMax; m++)
{
  for (int n = 0; n < basis.nMax(m); n++)
  {
    for (int n_z = 0; n_z < basis.n_zMax(m, n); n_z++)
    {
      psi_precalculate_v5.slice(indexes(m, n, n_z)) = basis.psi(rVals, zVals, m,  n,  n_z, poly.laguerre(m, n), poly.hermite(n_z));
    }
  }
}
arma::mat result5 = arma::zeros(rVals.n_rows, zVals.n_rows); // number of points on r- and z- axes
arma::mat result_temp2 = arma::zeros(rVals.n_rows, zVals.n_rows);
for (int m = 0; m < basis.mMax; m++)
{
  for (int n = 0; n < basis.nMax(m); n++)
  {
    for (int n_z = 0; n_z < basis.n_zMax(m, n); n_z++)
    {
      i = indexes(m, n, n_z);
      for (int np = 0; np < basis.nMax(m); np++)
      {
        for (int n_zp = 0; n_zp < basis.n_zMax(m, np); n_zp++)
        {   
          j = indexes(m, np, n_zp);
          if (i < j)
          result_temp2 += psi_precalculate_v5.slice(j) * rho(i, j);
        }
      }
      result5 += 2*psi_precalculate_v5.slice(i)%result_temp2; //adding for both i, j and j, i
      result_temp2.zeros();
      result5 += psi_precalculate_v5.slice(i) % psi_precalculate_v5.slice(i) * rho(i, i); //adding for i = j
    }
  }
}
```
.alert.hcenter[**0.065s** | Gain: **1.76**]

---

#Calcul / Optimisation #6 Moins de if

```cpp
//V6 - Like V5 but without if statement
arma::cube psi_precalculate_v6(rVals.n_rows, zVals.n_rows, basis.mMax*basis.nMax.max()*basis.n_zMax.max());
for (int m = 0; m < basis.mMax; m++)
{
  for (int n = 0; n < basis.nMax(m); n++)
  {
    for (int n_z = 0; n_z < basis.n_zMax(m, n); n_z++)
    {
      psi_precalculate_v6.slice(indexes(m, n, n_z)) = basis.psi(rVals, zVals, m,  n,  n_z, poly.laguerre(m, n), poly.hermite(n_z));
    }
  }
}
arma::mat result6 = arma::zeros(rVals.n_rows, zVals.n_rows); // number of points on r- and z- axes
arma::mat result_temp3 = arma::zeros(rVals.n_rows, zVals.n_rows);
for (int m = 0; m < basis.mMax; m++)
{
  for (int n = 0; n < basis.nMax(m); n++)
  {
    for (int n_z = 0; n_z < basis.n_zMax(m, n); n_z++)
    {
      i = indexes(m, n, n_z);
      for (int np = n; np < basis.nMax(m); np++)
      {
        for (int n_zp = np == n ? n_z + 1 : 0; n_zp < basis.n_zMax(m, np); n_zp++)
        {   
          j = indexes(m, np, n_zp);
          result_temp3 += psi_precalculate_v6.slice(j) * rho(i, j);
        }
      }
      result6 += 2*psi_precalculate_v6.slice(i)%result_temp3; //adding for both i, j and j, i
      result_temp3.zeros();
      result6 += psi_precalculate_v6.slice(i) % psi_precalculate_v6.slice(i) * rho(i, i); //adding for i = j
    }
  }
}
```
.alert.hcenter[**0.065s** | Gain: **1.00**]

---

#Calcul / Optimisation Récapitulatif

![](images/optimisation.png)

---

#Calcul / Optimisation Récapitulatif
## Avec option -O3 dans la compilation
![](images/tempso3.png)

---

#Résultats 
## Rotation
```cpp
arma::cube result3D;
result3D = arma::cube(2*result.n_rows-1, 2*result.n_rows-1, result.n_cols, arma::fill::zeros);
for (int i = 0; i<(int)result.n_cols; i++)
{
  for(int j = 0; j<2*(int)result.n_rows-1; j++)
  {
    for(int k = 0; k<2*(int)result.n_rows-1; k++)
    {
      double d = sqrt(pow((int)result.n_rows - k,2) + pow((int)result.n_rows - j,2));
      
      int l = (int)d;	
      if(l>(int)result.n_rows-1){
        l=result.n_rows-1;
      }
      result3D(j,k,i)=result(l,i);

    }
  }
}
result.save("result.csv", arma::csv_ascii); // save the 2D result in a csv file
```

---
#Résultats
## Tranche 2D
![](images/2.png)


---
#Résultats
## 3D
.hcenter.w80[![](images/vis.png)]

---
class: hcenter, middle
# Conclusion

.title[Conclusion]

???

Holy :cow: !!! I can put notes on my slides !?!
    </textarea>

    <script src="core/javascript/remark.js"></script>
    <script src="core/javascript/katex.min.js"></script>
    <script src="core/javascript/auto-render.min.js"></script>
    <script src="core/javascript/emojify.js"></script>
    <script src="core/javascript/mermaid.js"></script>
    <script src="core/javascript/jquery-2.1.1.min.js"></script>
    <script src="core/javascript/extend-jquery.js"></script>
    <script src="core/javascript/gitgraph.js"></script>
    <script src="core/javascript/plotly.js"></script>
    <script src="core/javascript/asciinema-player.js"></script>
    <script src="core/javascript/bokeh-2.2.1.min.js"></script>
    <script src="core/javascript/bokeh-widgets-2.2.1.min.js"></script>
    <script src="core/javascript/bokeh-tables-2.2.1.min.js"></script>
    <script src="core/javascript/bokeh-api-2.2.1.min.js"></script>

    <script>

    // === Remark.js initialization ===
    var slideshow = remark.create(
    {
      highlightStyle: 'monokai',
      countIncrementalSlides: false,
      highlightLines: false
    });

    // === Mermaid.js initialization ===
    mermaid.initialize({
      startOnLoad: false,
      cloneCssStyles: false,
      flowchart:{
        height: 50
      },
      sequenceDiagram:{
        width: 110,
        height: 30
      }
    });
    // ===== END =====

    renderMathInElement(document.body,{delimiters: [{left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false}], ignoredTags: ["script", "noscript", "style", "textarea", "pre"] });


    </script>
    <script src="gitgraphs.js" type="text/javascript"></script>
  </body>
</html>

